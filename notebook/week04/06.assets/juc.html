<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>

</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.6.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.3"></script><script>((e,t,r)=>{const{Markmap:n}=e();window.mm=n.create("svg#mindmap",null==t?void 0:t(),r)})(()=>window.markmap,t=>{return t=t||window.d3,{color:(n=t.scaleOrdinal(t.schemeCategory10),t=>n(t.p.i))};var n},{"t":"root","d":0,"v":"","c":[{"t":"paragraph","d":1,"p":{"lines":[0,1]},"v":"列举常用的并发操作 API 和工具类，简单分析其使用场景和优缺点。"},{"t":"heading","d":1,"p":{"lines":[4,5]},"v":"0 JUC","c":[{"t":"ordered_list","d":2,"p":{"lines":[8,10],"start":1},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[8,9],"index":1},"v":"1. 锁机制类 <strong>Locks</strong> :"}]},{"t":"ordered_list","d":2,"p":{"lines":[12,14],"start":2},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[12,13],"index":2},"v":"2. 原子操作类 <strong>Atomic</strong> :"}]},{"t":"ordered_list","d":2,"p":{"lines":[16,18],"start":3},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[16,17],"index":3},"v":"3. 线程池相关类 <strong>Executor</strong> :"}]},{"t":"ordered_list","d":2,"p":{"lines":[20,22],"start":4},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[20,21],"index":4},"v":"4. <strong>信号量三组工具类</strong> Tools :"}]},{"t":"ordered_list","d":2,"p":{"lines":[24,26],"start":5},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[24,25],"index":5},"v":"5. <strong>并发集合类 Collections</strong> :"}]}]},{"t":"heading","d":1,"p":{"lines":[30,31]},"v":"1 Locks","c":[{"t":"heading","d":2,"p":{"lines":[32,33]},"v":"使用场景 为什么需要显式的 Lock","c":[{"t":"list_item","d":4,"p":{"lines":[38,39],"index":1},"v":"1. 同步块的阻塞<strong>无法中断</strong>"},{"t":"list_item","d":4,"p":{"lines":[39,40],"index":2},"v":"2. 同步块的阻塞<strong>无法控制超时</strong>（无法自动解锁，系统被挂死）"},{"t":"list_item","d":4,"p":{"lines":[40,41],"index":3},"v":"3. 同步块<strong>无法异步处理锁</strong>（即不能立即知道是否可以拿到锁）"},{"t":"list_item","d":4,"p":{"lines":[41,42],"index":4},"v":"4. 同步块<strong>无法根据条件灵活的加锁解锁</strong>（即只能跟同步块范围一致）"}]},{"t":"heading","d":2,"p":{"lines":[43,44]},"v":"更自由的锁 Lock","c":[{"t":"list_item","d":4,"p":{"lines":[47,48],"index":1},"v":"1. 使用方式灵活可控"},{"t":"list_item","d":4,"p":{"lines":[48,49],"index":2},"v":"2. 性能开销小"},{"t":"list_item","d":4,"p":{"lines":[49,50],"index":3},"v":"3. 锁工具包: java.util.concurrent.locks"}]},{"t":"heading","d":2,"p":{"lines":[58,59]},"v":"ReentrantLock","c":[{"t":"bullet_list","d":3,"p":{"lines":[64,67]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[64,65]},"v":"支持重入"},{"t":"list_item","d":4,"p":{"lines":[65,66]},"v":"同时支持公平锁与非公平锁，非公平效率高，公平更注重时间先后"}]},{"t":"ordered_list","d":3,"p":{"lines":[69,76],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[69,70],"index":1},"v":"1. lock更灵活，可以自由定义多把锁的加锁解锁顺序（synchronized要按照先加的后解顺序）"},{"t":"list_item","d":4,"p":{"lines":[71,72],"index":2},"v":"2. 提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。"},{"t":"list_item","d":4,"p":{"lines":[73,74],"index":3},"v":"3. 本质上和监视器锁即synchronized是一样的"},{"t":"list_item","d":4,"p":{"lines":[75,76],"index":4},"v":"4. 能力越大，责任越大，必须控制好加锁和解锁"}]}]},{"t":"heading","d":2,"p":{"lines":[81,82]},"v":"读写锁 ReentrantReadWriteLock","c":[{"t":"list_item","d":4,"p":{"lines":[87,88]},"v":"读锁未释放，写锁不能写"}]},{"t":"heading","d":2,"p":{"lines":[95,96]},"v":"Condition"},{"t":"heading","d":2,"p":{"lines":[104,105]},"v":"LockSupport 锁当前线程"},{"t":"heading","d":2,"p":{"lines":[110,111]},"v":"用锁的最佳实践","c":[{"t":"ordered_list","d":3,"p":{"lines":[115,118],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[115,116],"index":1},"v":"1. 永远只在更新对象的成员变量时加锁"},{"t":"list_item","d":4,"p":{"lines":[116,117],"index":2},"v":"2. 永远只在访问可变的成员变量时加锁"},{"t":"list_item","d":4,"p":{"lines":[117,118],"index":3},"v":"3. 永远不在调用其他对象的方法时加锁"}]},{"t":"ordered_list","d":3,"p":{"lines":[123,125],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[123,124],"index":1},"v":"1. 降低锁范围：锁定代码的范围/作用域"},{"t":"list_item","d":4,"p":{"lines":[124,125],"index":2},"v":"2. 细分锁粒度：将一个大锁，拆分成多个小锁"}]}]}]},{"t":"heading","d":1,"p":{"lines":[128,129]},"v":"2 原子操作类Atomic","c":[{"t":"heading","d":2,"p":{"lines":[130,131]},"v":"使用场景","c":[{"t":"list_item","d":4,"p":{"lines":[136,137]},"v":"使用前面讲过的无锁技术","c":[{"t":"list_item","d":6,"p":{"lines":[137,138]},"v":"Unsafe API 中有一系列的方法 native的 CompareAndSwap"},{"t":"list_item","d":6,"p":{"lines":[138,139]},"v":"JVM 调用CPU 硬件指令 - CAS 指令"},{"t":"list_item","d":6,"p":{"lines":[139,140]},"v":"Value 的可见性 - volatile 关键字"}]}]},{"t":"heading","d":2,"p":{"lines":[141,142]},"v":"<strong>核心实现原理</strong>","c":[{"t":"list_item","d":4,"p":{"lines":[143,144],"index":1},"v":"1. volatile 保证读写操作都可见（注意不保证原子性）"},{"t":"list_item","d":4,"p":{"lines":[145,146],"index":2},"v":"2. 使用 CAS 指令，作为乐观锁实现，通过自旋重试保证写入"}]},{"t":"heading","d":2,"p":{"lines":[149,150]},"v":"锁与无锁","c":[{"t":"list_item","d":4,"p":{"lines":[155,156],"index":1},"v":"1. 压力非常小，性能本身要求就不高；"},{"t":"list_item","d":4,"p":{"lines":[156,157],"index":2},"v":"2. 压力一般的情况下，无锁更快，大部分都一次写入；"},{"t":"list_item","d":4,"p":{"lines":[157,158],"index":3},"v":"3. 压力非常大时，自旋导致重试过多，资源消耗很大。"}]},{"t":"heading","d":2,"p":{"lines":[167,168]},"v":"分段思想进一步改进","c":[{"t":"list_item","d":4,"p":{"lines":[181,182]},"v":"快排"},{"t":"list_item","d":4,"p":{"lines":[182,183]},"v":"G1 GC"},{"t":"list_item","d":4,"p":{"lines":[183,184]},"v":"ConcurrentHashMap"}]}]},{"t":"heading","d":1,"p":{"lines":[191,192]},"v":"3 线程池相关类 Executor","c":[{"t":"heading","d":2,"p":{"lines":[193,194]},"v":"为什么用线程池","c":[{"t":"bullet_list","d":3,"p":{"lines":[199,201]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[199,200]},"v":"线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，降低了计算机的整体性能。"},{"t":"list_item","d":4,"p":{"lines":[200,201]},"v":"对于重量级资源，倾向于用维护一个资源池的方式使用"}]},{"t":"bullet_list","d":3,"p":{"lines":[206,210]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[206,207]},"v":"<strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。"},{"t":"list_item","d":4,"p":{"lines":[207,208]},"v":"<strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。"},{"t":"list_item","d":4,"p":{"lines":[208,209]},"v":"<strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。"},{"t":"list_item","d":4,"p":{"lines":[209,210]},"v":"<strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。"}]}]},{"t":"heading","d":2,"p":{"lines":[217,218]},"v":"ThreadPoolExecutor","c":[{"t":"heading","d":3,"p":{"lines":[219,220]},"v":"总体设计","c":[{"t":"ordered_list","d":4,"p":{"lines":[223,228],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[223,224],"index":1},"v":"1. Excutor: 执行者，顶层抽象接口"},{"t":"list_item","d":5,"p":{"lines":[224,225],"index":2},"v":"2. ExcutorService: 接口 API"},{"t":"list_item","d":5,"p":{"lines":[225,226],"index":3},"v":"3. ThreadFactory: 线程工厂，配置executor参数"},{"t":"list_item","d":5,"p":{"lines":[226,227],"index":4},"v":"4. ThreadPoolExecutor 最常用"},{"t":"list_item","d":5,"p":{"lines":[227,228],"index":5},"v":"5. Excutors: 工具类，很多静态方法，帮助创建常用的线程池类型"}]},{"t":"bullet_list","d":4,"p":{"lines":[237,238]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[237,238]},"v":"线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。"}]}]},{"t":"heading","d":3,"p":{"lines":[241,242]},"v":"Executor – 执行者"},{"t":"heading","d":3,"p":{"lines":[246,247]},"v":"ExecutorService","c":[{"t":"bullet_list","d":4,"p":{"lines":[259,261]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[259,260]},"v":"更graceful"}]},{"t":"bullet_list","d":4,"p":{"lines":[269,274]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[269,270]},"v":"awaitTermination 一定时间，等待所有线程全部完成"},{"t":"list_item","d":5,"p":{"lines":[270,271]},"v":"到时后根据返回值判断是否所有的线程都停止"},{"t":"list_item","d":5,"p":{"lines":[271,272]},"v":"如果没有可以调用shutdownNow停止运行时间过长的线程","c":[{"t":"list_item","d":7,"p":{"lines":[272,273]},"v":"一般这时业务角度已经超时"}]}]}]},{"t":"heading","d":3,"p":{"lines":[274,275]},"v":"ThreadPoolExecutor","c":[{"t":"ordered_list","d":4,"p":{"lines":[284,287],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[284,285],"index":1},"v":"1. they usually provide improved performance when executing large numbers of asynchronous tasks, due to <strong>reduced per-task invocation</strong> overhead"},{"t":"list_item","d":5,"p":{"lines":[285,286],"index":2},"v":"2. and they provide a means of <strong>bounding and managing the resources</strong>, including threads, consumed when executing a collection of tasks."}]},{"t":"heading","d":4,"p":{"lines":[292,293]},"v":"ctl","c":[{"t":"list_item","d":6,"p":{"lines":[296,297]},"v":"workerCount, indicating the effective number of threads"},{"t":"list_item","d":6,"p":{"lines":[297,298]},"v":"runState,    indicating whether running, shutting down etc"}]},{"t":"heading","d":4,"p":{"lines":[313,314]},"v":"execute","c":[{"t":"list_item","d":6,"p":{"lines":[319,320],"index":1},"v":"1. 判断 corePoolSize 【创建】"},{"t":"list_item","d":6,"p":{"lines":[320,321],"index":2},"v":"2. 加入 workQueue"},{"t":"list_item","d":6,"p":{"lines":[321,322],"index":3},"v":"3. 判断 maximumPoolSize"},{"t":"list_item","d":6,"p":{"lines":[322,323],"index":4},"v":"4. 执行拒绝策略处理器"}]},{"t":"heading","d":4,"p":{"lines":[326,327]},"v":"重要属性及方法"}]},{"t":"heading","d":3,"p":{"lines":[330,331]},"v":"ThreadFactory"}]},{"t":"heading","d":2,"p":{"lines":[336,337]},"v":"线程池参数","c":[{"t":"heading","d":3,"p":{"lines":[338,339]},"v":"缓冲队列","c":[{"t":"ordered_list","d":4,"p":{"lines":[344,347],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[344,345],"index":1},"v":"1. ArrayBlockingQueue：规定大小的 BlockingQueue，<strong>其构造必须指定大小</strong>。。"},{"t":"list_item","d":5,"p":{"lines":[345,346],"index":2},"v":"2. LinkedBlockingQueue：<strong>大小不固定</strong>的 BlockingQueue，若其构造时指定大小，生成的BlockingQueue 有大小限制，不指定大小，其大小有 Integer.MAX_VALUE 来决定（可能导致堆内存溢出）。"}]},{"t":"ordered_list","d":4,"p":{"lines":[351,354],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[351,352],"index":1},"v":"1. PriorityBlockingQueue：类似于 LinkedBlockingQueue，依据对象的<strong>自然顺序</strong>或者构造函数的 <strong>Comparator</strong> 决定。"},{"t":"list_item","d":5,"p":{"lines":[352,353],"index":2},"v":"2. SynchronizedQueue：特殊的 BlockingQueue，对其的操作必须是<strong>放和取交替</strong>完成。"}]}]},{"t":"heading","d":3,"p":{"lines":[354,355]},"v":"拒绝策略","c":[{"t":"list_item","d":5,"p":{"lines":[356,357],"index":1},"v":"1. ThreadPoolExecutor.<strong>AbortPolicy</strong>: 丢弃任务并抛出 RejectedExecutionException异常","c":[{"t":"list_item","d":7,"p":{"lines":[357,358]},"v":"默认拒绝策略"},{"t":"list_item","d":7,"p":{"lines":[358,359]},"v":"抛出异常进行处理/记录"}]},{"t":"list_item","d":5,"p":{"lines":[359,360],"index":2},"v":"2. ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常"},{"t":"list_item","d":5,"p":{"lines":[360,362],"index":3},"v":"3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝<br>\n的任务"},{"t":"list_item","d":5,"p":{"lines":[362,363],"index":4},"v":"4. ThreadPoolExecutor.<strong>CallerRunsPolicy</strong>：由调用线程（提交任务的线程）处理该任务","c":[{"t":"list_item","d":7,"p":{"lines":[363,364]},"v":"目前用的比较多"}]}]}]},{"t":"heading","d":2,"p":{"lines":[367,368]},"v":"创建线程池方法","c":[{"t":"ordered_list","d":3,"p":{"lines":[371,375],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[371,374],"index":1},"v":"1. newSingleThreadExecutor<br>\n创建一个<strong>单线程的线程池</strong>。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的<br>\n线程因为异常结束，那么会有一个新的线程来替代它。"}]},{"t":"bullet_list","d":3,"p":{"lines":[375,377]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[375,376]},"v":"此线程池保证所有任务的执行顺序按照任务的提交顺序"}]},{"t":"ordered_list","d":3,"p":{"lines":[377,386],"start":2},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[377,380],"index":2},"v":"2. newFixedThreadPool<br>\n创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到<br>\n最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。"},{"t":"list_item","d":4,"p":{"lines":[380,382],"index":3},"v":"3. newCachedThreadPool<br>\n创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。","c":[{"t":"list_item","d":6,"p":{"lines":[382,383]},"v":"此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小"}]},{"t":"list_item","d":4,"p":{"lines":[383,385],"index":4},"v":"4. newScheduledThreadPool<br>\n创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。","c":[{"t":"list_item","d":6,"p":{"lines":[385,386]},"v":"不是立马执行，指定一个时间。"}]}]},{"t":"heading","d":3,"p":{"lines":[391,392]},"v":"创建固定线程池的经验","c":[{"t":"list_item","d":5,"p":{"lines":[395,396],"index":1},"v":"1. 如果是 CPU 密集型应用，则线程池大小设置为 N 或 N+1"},{"t":"list_item","d":5,"p":{"lines":[396,397],"index":2},"v":"2. 如果是 IO 密集型应用，则线程池大小设置为 2N 或 2N+2"}]}]},{"t":"heading","d":2,"p":{"lines":[404,405]},"v":"Callable – 基础接口","c":[{"t":"list_item","d":4,"p":{"lines":[408,409]},"v":"Callable#call()方法有返回值"}]},{"t":"heading","d":2,"p":{"lines":[412,413]},"v":"Future – 基础接口","c":[{"t":"heading","d":3,"p":{"lines":[418,419]},"v":"CompletableFuture"}]}]},{"t":"heading","d":1,"p":{"lines":[426,427]},"v":"4 <strong>信号量三组工具类</strong> Tools","c":[{"t":"heading","d":2,"p":{"lines":[428,429]},"v":"基础组件AQS","c":[{"t":"bullet_list","d":3,"p":{"lines":[434,436]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[434,435]},"v":"当state=0时，则说明没有任何线程占有共享资源的锁"},{"t":"list_item","d":4,"p":{"lines":[435,436]},"v":"当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待"}]},{"t":"bullet_list","d":3,"p":{"lines":[445,447]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[445,446]},"v":"当Condition调用wait()方法后，线程将会加入<strong>等待队列</strong>中，"},{"t":"list_item","d":4,"p":{"lines":[446,447]},"v":"当Condition调用signal()方法后，线程将从<strong>等待队列</strong>转移到<strong>同步队列</strong>中进行锁竞争。"}]},{"t":"bullet_list","d":3,"p":{"lines":[462,465]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[462,463]},"v":"共享模式是一个锁允许多条线程同时操作，如信号量<strong>Semaphore</strong>采用的就是基于AQS的共享模式实现"},{"t":"list_item","d":4,"p":{"lines":[463,464]},"v":"独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如<strong>ReentranLock</strong>"}]},{"t":"bullet_list","d":3,"p":{"lines":[467,468]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[467,468]},"v":"CANCELLED：即结束状态，值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，进入该状态后的结点将不会再变化。"}]}]},{"t":"heading","d":2,"p":{"lines":[473,474]},"v":"Semaphore - 信号量","c":[{"t":"list_item","d":4,"p":{"lines":[480,481]},"v":"准入数量 1 则等价于独占锁"}]},{"t":"heading","d":2,"p":{"lines":[492,493]},"v":"CountDownLatch"},{"t":"heading","d":2,"p":{"lines":[497,498]},"v":"CyclicBarrier","c":[{"t":"heading","d":3,"p":{"lines":[512,513]},"v":"与CountDownLatch的对比"}]}]},{"t":"heading","d":1,"p":{"lines":[517,518]},"v":"5 并发集合类 Collections","c":[{"t":"heading","d":2,"p":{"lines":[519,520]},"v":"CopyOnWriteArrayList","c":[{"t":"bullet_list","d":3,"p":{"lines":[527,530]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[527,528]},"v":"多个线程读的时候，都读到同一个副本快照。"},{"t":"list_item","d":4,"p":{"lines":[529,530]},"v":"多比较多写特别少的场景非常高效"}]},{"t":"ordered_list","d":3,"p":{"lines":[534,538],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[534,535],"index":1},"v":"1. 修改加锁，保证不会写混乱"},{"t":"list_item","d":4,"p":{"lines":[535,536],"index":2},"v":"2. 修改在Copy 的副本上，而不是原始数据上","c":[{"t":"list_item","d":6,"p":{"lines":[536,537]},"v":"新数组的操作，不会影响到对旧数组的读，读始终是不受影响的，直接读不加锁"},{"t":"list_item","d":6,"p":{"lines":[537,538]},"v":"修改操作完之后，将旧数组的指针指向新数组"}]}]}]},{"t":"heading","d":2,"p":{"lines":[547,548]},"v":"ConcurrentHashMap","c":[{"t":"heading","d":3,"p":{"lines":[551,552]},"v":"Java7 分段锁","c":[{"t":"list_item","d":5,"p":{"lines":[555,556]},"v":"降低锁粒度。 concurrentLevel = 16"},{"t":"list_item","d":5,"p":{"lines":[556,557]},"v":"操作时先hash取模判断在哪一个段，操作只锁这个段"},{"t":"list_item","d":5,"p":{"lines":[557,558]},"v":"每个段上一个小锁优于整个map一个大锁"}]},{"t":"heading","d":3,"p":{"lines":[567,568]},"v":"JDK8 数组加红黑树","c":[{"t":"list_item","d":5,"p":{"lines":[576,577]},"v":"CAS无锁并发技术的成熟，大部分情况下可以不需要加锁，也就不需要分段锁"},{"t":"list_item","d":5,"p":{"lines":[577,578]},"v":"规模比较大时使用红黑树，红黑树天然可以将线程分配到不同的分支上去"}]}]},{"t":"heading","d":2,"p":{"lines":[581,582]},"v":"线程安全实现的比较"}]}],"p":{}})</script>
</body>
</html>
