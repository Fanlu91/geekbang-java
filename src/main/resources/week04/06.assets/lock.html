<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>

</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.6.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.3"></script><script>((e,t,r)=>{const{Markmap:n}=e();window.mm=n.create("svg#mindmap",null==t?void 0:t(),r)})(()=>window.markmap,t=>{return t=t||window.d3,{color:(n=t.scaleOrdinal(t.schemeCategory10),t=>n(t.p.i))};var n},{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[2,3]},"v":"乐观锁 VS 悲观锁","c":[{"t":"bullet_list","d":2,"p":{"lines":[8,17]},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"<strong>悲观锁</strong>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。","c":[{"t":"list_item","d":5,"p":{"lines":[9,10]},"v":"Java中，synchronized关键字和Lock的实现类都是悲观锁。"},{"t":"list_item","d":5,"p":{"lines":[10,11]},"v":"悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。"}]},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"<strong>乐观锁</strong>认为自己在使用数据时不会有别的线程修改数据所以不添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。","c":[{"t":"list_item","d":5,"p":{"lines":[12,13]},"v":"如果这个数据没有被更新，当前线程将自己修改的数据成功写入"},{"t":"list_item","d":5,"p":{"lines":[13,14]},"v":"如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如自动重试或报/错）"},{"t":"list_item","d":5,"p":{"lines":[14,15]},"v":"乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的<strong>递增操作</strong><code>atomicInteger.incrementAndGet()</code>就通过CAS自旋实现的。"},{"t":"list_item","d":5,"p":{"lines":[15,16]},"v":"乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。"}]}]},{"t":"heading","d":2,"p":{"lines":[17,18]},"v":"CAS","c":[{"t":"bullet_list","d":3,"p":{"lines":[23,27]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[23,24]},"v":"需要读写的内存值 V。"},{"t":"list_item","d":4,"p":{"lines":[24,25]},"v":"进行比较的值 E。"},{"t":"list_item","d":4,"p":{"lines":[25,26]},"v":"要写入的新值 N。"}]},{"t":"bullet_list","d":3,"p":{"lines":[29,32]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[29,30]},"v":"失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试"},{"t":"list_item","d":4,"p":{"lines":[30,31]},"v":"无锁操作天生免疫死锁"}]},{"t":"heading","d":3,"p":{"lines":[32,33]},"v":"CPU指令对CAS的支持"},{"t":"heading","d":3,"p":{"lines":[41,42]},"v":"CAS的问题","c":[{"t":"bullet_list","d":4,"p":{"lines":[45,49]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[45,46]},"v":"可能发生了也不会造成什么问题"},{"t":"list_item","d":5,"p":{"lines":[46,47]},"v":"ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。"},{"t":"list_item","d":5,"p":{"lines":[47,48]},"v":"JDK从1.5开始提供了<code>AtomicStampedReference</code>类来解决ABA问题，具体操作封装在compareAndSet()中"}]},{"t":"bullet_list","d":4,"p":{"lines":[53,56]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[53,54]},"v":"CAS机制所保证的只是<strong>一个变量的原子性操作</strong>，而不能保证整个<strong>代码块的原子性</strong>。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。"},{"t":"list_item","d":5,"p":{"lines":[55,56]},"v":"Java从1.5开始JDK提供了AtomicReference类来保证<strong>引用对象</strong>之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。"}]}]}]}]},{"t":"heading","d":1,"p":{"lines":[58,59]},"v":"自旋锁 VS 适应性自旋锁","c":[{"t":"heading","d":2,"p":{"lines":[68,69]},"v":"自适应"}]},{"t":"heading","d":1,"p":{"lines":[78,79]},"v":"无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁","c":[{"t":"table","d":2,"p":{"lines":[90,96]},"v":"","c":[{"t":"thead","d":3,"p":{"lines":[90,91]},"v":"","c":[{"t":"th","d":5,"p":{"lines":[90,91]},"v":"锁状态"},{"t":"th","d":5,"p":{"lines":[90,91]},"v":"存储内容"},{"t":"th","d":5,"p":{"lines":[90,91]},"v":"标志位"}]},{"t":"tbody","d":3,"p":{"lines":[92,96]},"v":"","c":[{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"无锁"},{"t":"td","d":5,"p":{},"v":"对象的hashCode、对象分代年龄、是否是偏向锁（0）"},{"t":"td","d":5,"p":{},"v":"01"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"偏向锁"},{"t":"td","d":5,"p":{},"v":"偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）"},{"t":"td","d":5,"p":{},"v":"01"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"轻量级锁"},{"t":"td","d":5,"p":{},"v":"指向栈中锁记录的指针"},{"t":"td","d":5,"p":{},"v":"00"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"重量级锁"},{"t":"td","d":5,"p":{},"v":"指向互斥量（重量级锁）的指针"},{"t":"td","d":5,"p":{},"v":"10"}]}]}]},{"t":"bullet_list","d":2,"p":{"lines":[105,109]},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[105,106]},"v":"只有等到线程竞争出现才释放偏向锁，持有偏向锁的线程不会主动释放偏向锁。"},{"t":"list_item","d":3,"p":{"lines":[106,107]},"v":"之后的线程竞争偏向锁，会先检查持有偏向锁的线程是否存活，如果不存货，则对象变为无锁状态，重新偏向；"},{"t":"list_item","d":3,"p":{"lines":[107,108]},"v":"如果仍存活，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁"}]},{"t":"bullet_list","d":2,"p":{"lines":[111,118]},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[111,112]},"v":"在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（<strong>Lock Record</strong>）的空间，用于存储锁同步对象目前的Mark Word的拷贝（即将对象头中的Mark Word复制到锁记录中），官方称之为 <code>Displaced Mark Word</code>。"},{"t":"list_item","d":3,"p":{"lines":[112,113]},"v":"虚拟机使用CAS操作尝试将锁对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向对象的Mark Word。","c":[{"t":"list_item","d":5,"p":{"lines":[113,114]},"v":"如果成功，这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态"},{"t":"list_item","d":5,"p":{"lines":[114,115]},"v":"若失败：虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，若当前只有一个等待线程，则可通过自旋等待一下，可能持有轻量级锁的线程很快就会释放锁","c":[{"t":"list_item","d":7,"p":{"lines":[115,116]},"v":"当自旋超过一定的次数，轻量级锁膨胀为重量级锁"},{"t":"list_item","d":7,"p":{"lines":[116,117]},"v":"一个线程持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁"}]}]}]},{"t":"bullet_list","d":2,"p":{"lines":[128,131]},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[128,129]},"v":"加锁解锁操作需要额外操作；"},{"t":"list_item","d":3,"p":{"lines":[130,131]},"v":"互斥同步对性能最大的影响是阻塞的实现，因为阻塞涉及到的挂起线程和恢复线程的操作都需要转入内核态中完成（用户态与内核态的切换的性能代价是比较大的）"}]},{"t":"heading","d":2,"p":{"lines":[134,135]},"v":"无锁"},{"t":"heading","d":2,"p":{"lines":[142,143]},"v":"<strong>偏向锁</strong>","c":[{"t":"heading","d":3,"p":{"lines":[150,151]},"v":"释放"}]},{"t":"heading","d":2,"p":{"lines":[158,159]},"v":"<strong>轻量级锁</strong>"},{"t":"heading","d":2,"p":{"lines":[172,173]},"v":"<strong>重量级锁</strong>"}]},{"t":"heading","d":1,"p":{"lines":[178,179]},"v":"公平锁 VS 非公平锁","c":[{"t":"bullet_list","d":2,"p":{"lines":[182,185]},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[182,183]},"v":"优点是等待锁的线程不会饿死。"},{"t":"list_item","d":3,"p":{"lines":[183,184]},"v":"缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。"}]},{"t":"bullet_list","d":2,"p":{"lines":[187,190]},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[187,188]},"v":"优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。"},{"t":"list_item","d":3,"p":{"lines":[188,189]},"v":"缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。"}]}]},{"t":"heading","d":1,"p":{"lines":[200,201]},"v":"可重入锁 VS 非可重入锁","c":[{"t":"heading","d":2,"p":{"lines":[211,212]},"v":"为什么在嵌套调用时可自动获得锁？"}]},{"t":"heading","d":1,"p":{"lines":[221,222]},"v":"独享锁 VS 共享锁"},{"t":"heading","d":1,"p":{"lines":[231,232]},"v":"死锁问题","c":[{"t":"heading","d":2,"p":{"lines":[235,236]},"v":"四个必要条件"},{"t":"heading","d":2,"p":{"lines":[247,248]},"v":"<strong>死锁的处理</strong>"}]}],"p":{}})</script>
</body>
</html>
